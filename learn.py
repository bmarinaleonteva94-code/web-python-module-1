# \n - перевод на новую строку   \ - экранирование

# print("H", "e", "l", "l", "o", sep = "-")      # sep - параметр, указывающий разделитель между выводимыми аргументами; H-e-l-l-o
# print("My", "name", "is", sep="_", end="*")     # end - параметр, указывающий на то, что выведется после вывода всех аргументов: My_name_is*

# print(0o123)    # префиксы 0o или 0O  предшествуют 8-ричным числам, в выводе автоматически преобразуются в десятичное значение: 123 = 83 в десятичном представлении чисел
# print(0x123)    # 0x или 0X перед 16-теричными числами
# # None - отсутствие объекта

# print(5//2)      # // целочисленное деление, результат 2
# print(5%2)       # % остаток от деления, ответ 1
# print(5**2)       # ** возведение в степень


# a = 3.0
# b = 4.0
# c = (a ** 2 + b ** 2) ** 0.5
# print("c =", c)

# fnam = input("May I have your first name, please? ")
# lnam = input("May I have your last name, please? ")
# print("\nYour name is " + fnam + " " + lnam + ".")      # + оператор конкатенации строк(их сложение, слияние), все аргументы должны быть строками


# Если знак * (звездочка) применить к строке и числу, то он станет оператором повторения строки:
# строка * число
# число * строку            повторяет строку столько раз, сколько указано в числе, если число меньше или равно нулю, результатом вывода будет пустая строка
#  следующая программа нарисует прямоугольник:
# print("+" + 10 * "-" + "+")     
# print(("|" + " " * 10 + "|\n") * 5, end="")
# print("+" + 10 * "-" + "+")

# рисуем угол:
# print(5*" " + "/\\" + 5*" ")
# print(4*" " + "/" + 2*" " + "\\")
# print(3*" " + "/" + 4*" " + "\\")
# print(2*" " + "/" + 6*" " + "\\")
# print(" " + "/" + 8*" " + "\\")


# ---------------------------------------------
#             СТРОКИ
#  индекс последнего символа в строке = длина строки - 1

# str = "hello"
# str2 = "world"
# print(str[1])      # рез-т е
# print(str[-1])     # рез-т о; отсчет с конца строки
# print(str*5)       # дублирование строки 5 раз, рез-т - новый объект
# print(str + str2)  # конкатенация, рез-т - новый объект, без пробелов
# print(len(str))    # длина строки

#  МЕТОДЫ ДЛЯ ИЗМЕНЕНИЯ РЕГИСТРА СТРОКИ
# str.capitalize()     # первый символ str в верхний регистр, остальные — в нижний, возвращаемый результат — преобразованная копия оригинальной строки str, при этом оригинальная строка в результате работы метода не изменится, как и в случае использования рассмотренных ниже методов преобразования регистра
# str.lower()          # переводит все буквенные символы оригинальной строки в нижний регистр
# str.upper()          # преобразует все буквенные символы str в верхний регистр
# str.title()          # преобразует первые буквы каждого слова в строке str в верхний регистр (а остальные буквы слов переводит в нижний регистр)
# str.swapcase()       # преобразует буквенные символы строки str, меняя их регистр на противоположный

#   МЕТОДЫ ПОИСКА ПОДСТРОКИ В СТРОКЕ
# str.count(pattern [, startIndex [, endIndex]]) — определяет количество вхождений фрагмента pattern в строку str (или в ее часть при задании диапазона поиска (с индекса startIndex … по индекс endIndex …)
# print(str.count("s"))
# str.find(pattern [, startIndex [, endIndex]]) — для поиска в строке str нужного фрагмента pattern, возвращаемый результат  — индекс начала первого вхождения фрагмента pattern в строку str или -1 в случае, если фрагмент pattern не входит в состав str
# str.index(pattern [, startIndex [, endIndex]]) — аналогична методу .find(), отличие — в вызове исключения ValueError в случае, когда фрагмент pattern не найден (не входит в состав str)
# str.rfind(pattern [, startIndex [, endIndex]]) — для поиска в строке str нужного фрагмента pattern, начиная с конца строки str, возвращаемый результат  — индекс начала последнего вхождения фрагмента pattern в строку str или -1 в случае, если фрагмент pattern не входит в состав str
# str.rindex(pattern [, startIndex [, endIndex]]) - аналогична методу .rfind(), отличие — в вызове исключения ValueError в случае, когда фрагмент pattern не найден (не входит в состав str)

#  МЕТОДЫ ПРОВЕРКИ НАЧАЛА (ОКОНЧАНИЯ) СТРОК
# Методы возвращают True в случае, когда оригинальная строка удовлетворяет условию, False — иначе. Для ограничения диапазона проверки можно использовать параметры startIndex и endIndex.
# str.endswith(pattern [, startIndex [, endIndex]]) — определяет, заканчивается ли строка str указанным фрагментом pattern
# str.startwith(pattern [, startIndex [, endIndex]]) — определяет, начинается ли строка str с указанного фрагмента pattern

#  МЕТОДЫ ПРОВЕРКИ СТРОК
# Проверяют, состоит ли строка из определенных символов, например, цифр. Все они, как результат, возвращают значение True — если строка содержит нужные символы, False — иначе).
# str.isalnum() — проверяет, состоит ли строка str только из буквенных и цифровых символов.
# str.isalpha() — проверяет, состоит ли строка str только из буквенных символов.
# str.isdigit() — проверяет, состоит ли строка str только из цифровых символов (используется для проверки, является ли строка str числом).
# str.islower() проверяет, находятся ли все буквенные символы строки str в нижнем регистре (символы строки str, которые не являются буквой алфавита — игнорируются данной проверкой).
# str.isspace() проверяет, что в состав строки str входят только пробельные символы, к которым относятся символы пробела ' ', табуляции '\t' и перехода на новую строку '\n'.
# str.istitle() проверяет, начинается ли каждое слово строки str с символа в верхнем регистре.
# str.isupper() определяет, находятся ли все буквенные символы строки str в верхнем регистре.
# str.islower() определяет, находятся ли все буквенные символы строки str в нижнем регистре

#  МЕТОДЫ ФОРМАТИРОВАНИЯ СТРОК
# str.center(width [, fillchar]) - дополняет (расширяет) строку str до указанной длины width, возвращаемый результат — расширенная копия строки str. Если параметр fillchar указан, то он будет использован, как символ заполнения, иначе — отступы заполняются пробелами. В случае, если параметр width меньше или равен длине строки str, то строка не изменяется
# print(str.center(30, "*"))
# str.expandtabs(tabsize = 8) - возвращает копию строки str, в которой каждый символ табуляции ('\t') заменен на пробел, количество которых задается через параметр tabsize. Если параметр tabsize не задан, то каждый символ табуляции заменяется на 8 пробелов.
# str.ljust(width [, fillchar]) возвращает выровненную по левому краю копию строки str указанной ширины width. Если параметр fillchar задан, то он используется для заполнения недостающего количества символов, иначе используется символ пробела. В случае, если параметр width меньше или равен длине строки str, то строка не изменяется
# str.rjust(width [, fillchar])  аналогичное выравнивания строки по правому краю в поле указанной ширины
# str.lstrip([characters]) возвращает копию строки str, удаляя начальные символы (слева), указанные в качестве аргумента characters. Если параметр characters не указан, то удаляются символы пробелов
# str.rstrip([characters]) аналогичное удаление завершающих символов (или пробелов) в строке справа
# str.strip([characters]) удаляет пробелы (или указанные символы) и с левой, и с правой стороны строки
# str.zfill(width) дополняет строку слева символами «0» ширины width. Если строка str содержит какой-либо символ перед цифрами, то он остается в левой части строки и заполнение нулями происходит после него

#  ----------------------------------------------------------------------------------------------------------------------------------
#        СПИСОК (LIST)
#  может хранить элементы разных типов
#  размер динамический (можно добавлять/удалять данные)
#  индексация с 0
#  мутабельный

# Создание списка
empty_list = []     # пустой список
courses = list(("Math", "Algorithms"))   # с помощью встроенной функции list
students = list()      # пустой список
fruits = ["lemon", "apple", "orange", "watermelon"]
print(empty_list)
print(courses)
print(students)
print(fruits)

numbers = [1,2,3,4,3,2,-5]
print(len(numbers))      #возвращает длину списка (количество элементов в списке)
print(max(numbers))       # возвращает максимальный элемент в списке, для чисел
print(min(numbers))      # возвращает минимальный элемент в списке, для чисел
print(sum(numbers))     #  возвращает сумму значений в списке, для чисел
print(sorted(numbers))    # возвращает копию списка, в котором элементы упорядочены по возрастанию (в случае числовых значений) или по алфавиту

